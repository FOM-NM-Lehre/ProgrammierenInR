---
engine: knitr
filters:
  - webr
---
<!--

# Das Tidyverse

-->

## Vorbereitung

Pakete kann mensch bequem über die IDE installieren oder einfach mit einem _R_-Befehl:

```{r}
#| eval: false
#| echo: true
install.packages(c("tidyverse", "palmerpenguins", "nycflights13", "janitor", "lubridate", "stringr"))
```

Es ist wichtig, dass Sie für diesen Abschnitt alle Pakete installiert haben. -- Aber keine Angst, sollten Sie ein Paket schon istalliert haben, dann wird es maximal auf die aktuelle Version upgedated!


## Das `tidyverse`

`tidyverse` ist eine Sammlung von aufeinander abgestimmter Pakete für die Arbeit mit Daten.

**Kernpakete:** 

::: {.columns}
::: {.column width="49%"}
- [`readr`](https://readr.tidyverse.org) (Einlesen),
- [`tibble`](https://tibble.tidyverse.org) (Datenstruktur),
- [`dplyr`](https://dplyr.tidyverse.org/reference/tbl.html) (Transformation), 
- [`tidyr`](https://tidyr.tidyverse.org) (Umformen), 
:::
::: {.column width="49%"}
- [`ggplot2`](https://ggplot2.tidyverse.org) (Graphiken), 
- [`stringr`](https://stringr.tidyverse.org) (Text), 
- [`forcats`](https://forcats.tidyverse.org) (Kategorielle Variablen/Faktoren), 
- [`lubridate`](https://lubridate.tidyverse.org) (Daten/Zeit).
:::
:::

**Philosophie:** Ein Datenzusammenhang pro Tabelle, eine Variable pro Spalte, eine Beobachtung pro Zeile; klare, “verb”-artige Funktionen.

\

**Pipes:** Verkette Schritte mit dem Base-Pipe `|>` (oder `%>%`) um lineare, lesbare Workflows zu bauen.


## Anmerkung zu den Beispiel Daten "palmerpenguins"

Wir schauen uns die Daten der "[Palmer Penguins](https://allisonhorst.github.io/palmerpenguins/)" an.

Es wurden auf drei Inseln ("Biscoe", "Dream" und "Torgersen") der Antarktic drei Arten von Piguinen ("Adelie", "Chinstrap" und "Gentoo") beobachtet.^[Paper zu den Daten finden Sie [hier](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0090081)]

![.](./images/iter_penguins.png){width=60%}


## Anmerkung zu den Beispiel Daten "palmerpenguins"

![.](./images/palmerpenguins_orte.png){width=60%}


## Beispiel 

Wir haben schon ein wenig mit dem `tidyverse` gearbeitet, daher können Sie sich sicher denken, was wir hier ausgeben wollen:

```{webr-r}
#| warning: false
#| autorun: false
library(tidyverse)
library(palmerpenguins)

penguins |>
  drop_na() |>
  mutate(bmi = body_mass_g / flipper_length_mm) |>
  group_by(species) |>
  summarise(mean_bmi = mean(bmi), n = n(), .groups = "drop") |>
  arrange(desc(mean_bmi))
```


## Einlesen von Daten - Vorbereitung

Wir wollen nun Daten aus einer csv Datei einlesen. Dafür verwenden wir das Paket [`readr`](https://readr.tidyverse.org) aus dem [`tidyverse`](https://www.tidyverse.org). 
Es gibt aber auch Bord-Mittel. Schauen Sie sich gerne einmal die Befehle `read.csv()` und `read.csv2()` an. 

```{r}
#| warning: false
#| echo: true
#| eval: true
library(readr)
library(here)
```

Wir lesen nun die Daten "sales.csv" aus dem Verzeichnis "data" ein:

```{r}
#| echo: true
#| eval: true
here("data", "sales.csv") |> 
    read_csv() -> 
    df 
```

Und geben die Spaltennamen aus:

```{r}
#| echo: true
#| eval: true
colnames(df)
```


**Fragen an Sie:** _Sind diese Variabel-/Spaltennamen "schön"? - Was ist Ihre Meinung?_


## Einlesen von Daten und Variabelnamen vereinheitlich mit dem Paket `janitor`

```{r}
#| echo: true
#| eval: true
library(janitor)

here("data", "sales.csv") |> 
    read_csv() |>
    clean_names()  ->  # macht spalten_namen_einheitlich 
    df
```


Wie schauen die Spaltennamen nun aus?

```{r}
#| echo: true
#| eval: true
colnames(df) 
```


## Nochmal etwas Selektieren und Filtern

Wir erinnern uns: _Mit `select()` selektieren wir Spalten. Mit `filter()` filtrieren wir Zeilen._

Erzeugen wir also eine neue Tabelle mit dem Namen `df_small`, die 
- nur die Spalten *order_date*, *region* und alle Spalten die mit *total_* beginnen enthält. 
- Danach nur die Regionen "Europa" und "North America" enthält, die einen "total_revenue" von mit als 50000 Dollar haben: 


```{r}
#| echo: true
#| eval: true
library(dplyr)
df |>
    select(order_date, region, starts_with("total_")) |>
    filter(region %in% c("Europe", "North America"), total_revenue > 50000) ->
    df_small
```


## Die Marge als neue Spalte *margin* hinzufügen

Fügen wir die Marge als neue Spalte *margin* hinzu. Die Marge ist der Quotient aus *total_profit* und *total_revenue*. 
Sortieren wir dann das Ergebnis absteigend (vgl: `desc()`) bzgl. der Spalte *margin*., speichern das Ergebnis in `df_aug` und
geben anschließend die ersten 6 Zeilen der neuen Tabelle (`head()`) aus:

```{r}
#| echo: true
#| eval: true
df_small |>
    mutate(margin = total_profit / total_revenue) |>
    arrange(desc(margin)) -> 
    df_aug

head(df_aug)
```


## Eine kurze Zusammenfassung der Daten

Wenn wir nun die mittleren Marge (*mean_margin*) und die Gesamtumsatz (*total_rev*) für jeweils unsere Regionen bestimmen möchten können wir den Befehll (`summarize()`) nutzen:

```{r}
#| echo: true
#| eval: true
df_aug |>
    group_by(region) |>
    summarise(
        mean_margin = mean(margin, na.rm = TRUE),
        total_rev   = sum(total_revenue, na.rm = TRUE),
        .groups = "drop"
    ) -> 
    by_region

by_region
```


## Eine andere Aufgabe

Etwas trickreicher müssen wir vorgehen, wenn wir für den Gesamtumsatz (*total_revenue*), die Gesamtkosten (*total_costs*) und den Gesamtgewinn (*total_profit*) die Durchschnitte und deren Standardabweichungen in eine neue Tabelle speichern wollen: 

::: {.columns}
::: {.column width="43%"}
Wir beginnen mit einer Funktion, die uns für jeden übergebenen Wert eine Tabelle (`tibble`) mit dem Mittelwert *mean* und der Standardabweiung *sd* zurückliefert:
```{r}
#| echo: true
#| eval: true
mean_sd <- function(x) {
    tibble(
        mean = mean(x),
        sd = sd(x)
    )
}
```

Diese Funktion nutzen wir und erzeugen eine neue Tabelle, in dem wir durch alle Spalten von *total_revenue* bis *total_profit* durchlaufen und diese der Funktion `mean_sd()` übergeben.
:::
::: {.column width="57%"}

 Das Ergebnis kommt dann in die Tabelle *df_stats*:

```{r}
#| echo: true
#| eval: true
df |>
    reframe(
        across(
            total_revenue:total_profit, 
            mean_sd,
            .unpack = TRUE
        )
    ) -> df_stats    

df_stats
```
:::
:::

## Ein neues Beispiel: New York City Flüge aus dem Jahre 2013

::: {.columns}
::: {.column width="39%"}
Im Paket `nycflights13` sind Tabellen über Die An- und Abflüge auf dem Flughafen New York City aus dem Jahre 2013 gespeichert.

```{webr-r}
#| autorun: true
library(nycflights13)
```

Wir schauen uns zunächst die Daten an:

```{webr-r}
#| autorun: true
colnames(flights)
```

::: 
::: {.column width="60%"}

![.](./images/nycflights13-er-diagramm.png)

:::
:::


## Wir identifizieren Fluggesellschaft über ihre Abkürzungen

Dazu erstellen wir einen *left join*, so wie Sie ihn aus SQL kennen:

```{webr-r}
#|  autorun: false
flights |>
    left_join(airlines, by = "carrier") ->
    flights_named

colnames(flights_named)

flights_named %>%
    select(carrier, name) %>%
    head()
```


## Nur die A320 Maschinen bitte!

Wir wollen wissen welche Fluggesellschaften im Februar mit einem Airbus A320 (egal welcher Baureihe) in New York City war:

```{webr-r}
#|  autorun: false
library(stringr)

flights_named |>
    left_join(planes, by = "tailnum") |>
    filter(month == 2) |>
    filter(str_detect(model, "^A320")) |>  # str_detect aus stringr
    select(name) |>
    unique()
```

